# parse.pl
#
# Copyright 1999, Melampus Enterprises, Inc.
# Author: Michael J. Duff
# Last modified: June 6, 2007
#
# Description:
#   Routines for parsing key-value pairs from forms, and for
#   parsing persistent cookies.
#

use CGI;


sub parse_cgi_data
{
    my $cgi_data = {};

    my $cgi = new CGI;

    foreach my $key ($cgi->param()) {
	if ($key =~ /\[\]$/) {
	    my @values = $cgi->param ($key);
	    my %h = ();
	    foreach my $value (@values) {
		# Permit case where options are generated by form prepopulation:
		if ($value =~ /^<option>.*<\/option>$/) { $h{$value} = 1; }
		else                                    { $h{CGI::escapeHTML ($value)} = 1; }
	    }
	    $cgi_data->{$key} = [keys (%h)];
	    #print "\r\n\r\nTest: '$key'" . $cgi_data->{$key}[0] . "<br>\n";

	} else {
	    my $value = $cgi->param ($key);
	    # Permit case where options are generated by form prepopulation:
	    if ($value =~ /^<option>.*<\/option>$/) { $cgi_data->{$key} = $value; }
	    else                                    { $cgi_data->{$key} = CGI::escapeHTML ($value); }
	}
    }

    return $cgi_data;
}



sub return_error
{
    my ($status, $keyword, $message) = @_;
 
    print "Content-type: text/html", "\n";
    print <<"End_of_Error";

<HTML>
<HEAD> <TITLE>CGI Program - Unexpected Error</TITLE> </HEAD>

<BODY>
Status:$status $keyword
</BODY>
</HTML>

End_of_Error

    exit(1);
}



sub parse_persistent_cookies
{
    my $cookie_data = {};

    my @key_value_pairs = split (/;\s/, $ENV{'HTTP_COOKIE'});

    my ($key_value, $key, $value);
    foreach $key_value (@key_value_pairs) {
	($key, $value) = split (/=/, $key_value);

	#$key =~ tr/+/ /;
	$key =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;

	#$value =~ tr/+/ /;
	$value =~ s/%([\dA-Fa-f][\dA-Fa-f])/pack ("C", hex ($1))/eg;

	$cookie_data->{$key} = $value;
    }

    return $cookie_data;
}


1;
